
\section{Warum braucht man FIDIUS?}
\label{sec:motivation:need}

\authors{\DE \and \JF}{\LM \and \MW \and \DH}

Bei der Entwicklung von Software werden häufig Test-Frameworks
benutzt, um die geschriebenen Programme zu testen. Für nahezu jede
Sprache existiert mindestens ein solches Framework, mit Hilfe dessen
Tests für definierte Ein- und Ausgaben des eigenen Programms
geschrieben werden können. So kann ein Entwickler stets überprüfen, ob
die entstandene Software sich den Anforderungen entsprechend verhält.

Solche Testprogramme werden bei größeren Software-Projekten
vollautomatisch durchgeführt (\zB jede Nacht). Falls einer der Tests
fehlschlägt, so erhält der entsprechende Entwickler oder das
Entwicklerteam eine Nachricht. So können die Programmierer jede Nacht
vollautomatisch überprüfen lassen, ob die tags zuvor gemachten Änderungen
negative Auswirkungen auf das System haben, die sie bei der
Entwicklung eines kleinen Bausteines nicht bedacht haben.

Zudem bieten solche Tests Sicherheit für die Kunden. Denn diese können
davon ausgehen, dass zumindest ein großer Teil der Software immer
wieder auf die Funktionstüchtigkeit und Korrektheit überprüft wird.

Jedoch können solche Tests niemals alle möglichen Eingaben
abdecken. Ein Textfeld auf einer Website zum Beispiel, das nur eine
Zeichenkette mit maximal 10 Zeichen Länge bestehend aus Buchstaben und
Zahlen als Eingabe akzeptiert, käme auf $10^{26\cdot 2 + 10}$
verschiedene mögliche Eingaben eines Benutzers nur für dieses Feld,
von denen es noch etliche mehr in einer Software geben wird. Es ergibt
also Sinn diese Tests einzuschränken.

Noch komplexer wird es, wenn eine Software mit Werten arbeitet, die
von Sensoren als Bitmuster geliefert werden. Diese Sensoren können
nahezu beliebig lange Bitmuster enthalten. Bei einer Software, die
Netzverkehr überwacht und prüft, ob sich in einem Paket, welches über
das Netz gesendet wird, maliziöser Code befindet, müsste theoretisch
eine so große Menge an Tests durchgeführt werden, dass die Zahl hier
kaum aufzuschreiben ist.

Eine Lösung dieses Problems ist das Klassifizieren von möglichen
Mustern, die ein solcher Sensor aus einem Netz abliest. Bei einem
\gls{glos:ids} gibt es hierzu eine Menge an bekannten Mustern, die als
maliziös klassifiziert werden, aber auch bekannte Muster, die
nachweislich beim Lesen von E-Mails oder beim Surfen im Web entstehen.

Möchte man ein \gls{glos:ids} entwickeln, so benötigt man also
zweierlei. Erstens braucht man ein Framework, das eine bestimmte,
eingeschränkte aber repräsentative Menge von Eingaben enthält und man
braucht eine Menge an Sensor-Daten, die vom Sensor aus dem Netz
gelesen werden. Hier ergibt es ebenfalls Sinn, eine eingeschränkte
aber repräsentative Menge von möglichem Netzverkehr zu
simulieren. Dieser Netzverkehr wird dann innerhalb des Tests vom
Sensor erfasst und dem \gls{glos:ids} zur Verarbeitung
weitergereicht. Anhand der Reaktion des \gls{glos:ids} auf die
eingespielten Sensor-Daten könnte man dann Rückschlüsse daraus ziehen,
wie sich die Software bei anderem Netzverkehr verhält. Dies verhält
sich ähnlich zu den Tests für Nutzereingaben, bei denen durch die
eingeschränkte Menge an Tests ebenfalls versucht wird, Vorhersagen
darüber zu treffen, wie sich das System bei ähnlichen Eingaben
verhalten würde.

Bei einem Test für den Teil der Software, der mit Benutzereingaben arbeitet,
wird immer mit den gleichen Testdaten gearbeitet, um eine
Vergleichbarkeit der Tests zu ermöglichen. Dies bedeutet natürlich
nicht, dass die Testdaten nicht um Sonderfälle erweitert werden
können. Man nutzt jedoch einen vorgegebenen Datensatz, um einen
wiederholten Test vergleichbar zum vorherigen zu machen. Dies
ermöglicht eine genaue Aussage darüber, ob eine falsche Reaktion auf
eine Eingabe korrigiert worden ist oder nicht. 

Auch ein Sensor eines \gls{glos:ids} sollte immer wieder mit gleichen
Daten getestet werden können, um zu entscheiden, ob sich das System in
allen Situationen immer noch wie erwartet verhält. So kann die
Reaktion auf bekannte Angriffe und auf Netzverkehr, der bei üblichem
Gebrauch eines Netzes entsteht, überprüft werden. Entsprechend des
Ergebnisses kann dann der Programmteil, der auf die Sensordaten
reagiert, in seinen Einstellungen angepasst werden.

Denn das zentrale Problem beim Testen eines \gls{glos:ids} ist es,
dass man zwar Netzverkehr zum Testen selbständig erzeugen kann, bei
diesem dann jedoch nicht klar ist, welche Pakete zum Angriff gehören,
und welche nicht. Dies haben Gespräche mit Forschern der Universität
Bremen ergeben, die auf dieses Problem in verschiedenen Projekten
gestoßen sind. 

Daher wurde von uns \f entwickelt. \f ermöglicht, wie später in diesem
Dokument noch detaillierter erläutert werden wird, \glspl{glos:ids}
wiederholt zu testen. Durch die Architektur und durch die Anbindung an
bestehende \gls{glos:oss} ist unser Test-Framework einfach erweiterbar
und praktikabel.
