\chapter{Ergebnisse}
\label{chp:conclusion}
\authors{\DE \and \LM}{\MW \and \DH \and \HM}

\section{IDS Testen}
In Abschnitt~\ref{chp:objectives-functions-idstest} haben wir definiert, dass
eines unserer Ziele das Testen von \glospl{ids} ist. Hierzu haben
wir die EvasionDB entwickelt, mit der man in der Lage ist, die
Meldungen eines \glos{ids} zu überwachen. Wir haben uns dabei
auf das \glos{ids} \glos{prelude-ids} und damit auf das
\acr{idmef}, welches im \acr{rfc} 4765~\cite{rfc-4765} bereits beschrieben ist,
beschränkt. Hier ging es uns primär darum die Machbarkeit aufzuzeigen
ein \acr{ids} sinnvoll testen zu können.


\subsection{Testverfahren}

Um ein \gls{glos:ids} sinnvoll zu testen, muss eine bestimmte
definierte Menge an Angriffen durchgeführt werden. Hinzu muss normaler
Netzverkehr kommen, in dem keine Angriffe enthalten sind. Getestet
wird dann, 1. ob das \glos{ids} alle gestarteten Angriffe und deren
einzelnen Schritte erkannt hat (geringe False-Negativ-Rate) und 2. ob
das \glos{ids} keinen Angriff innerhalb des normalen, nicht gefährlichen
Netzverkehrs erkannt hat (geringe False-Positive-Rate).


\subsection{Automatisches Erzeugen von Netzverkehr}

Hierzu haben wir das \acr{msf} über eine Schnittstelle
angesprochen, um die Angriffe zu senden und ein eigenes
sog. \Gls{glos:auxiliary} geschrieben, welches normalen Verkehr simuliert, etwa
den eines Benutzers, der im Internet Websites aufruft oder E-Mails
versendet und empfängt.


\subsection{Automatische Auswertung von IDS-Meldungen}

Zur automatischen Auswertung haben wir ein Programm geschrieben,
welches abwechselnd Angriffe und nicht maliziösen Netzverkehr
sendet. Die Meldungen des \glos{ids} werden dann in einer Datenbank
gespeichert und können ausgewertet werden. Wie im Abschnitt
\ref{chp:outlook} beschrieben, ist eine Aufgabe die noch ansteht, die
automatische Zusammenfassung der Ergebnisse und die Ausgabe auf einer
Website oder einer PDF-Datei. Hier könnte dann eine Bewertung eines
\glos{ids} über die False-Negative- und False-Positive-Rate ausgegeben
werden. 

\section{IDS automatisch konfigurieren}

Im Laufe des Projektes kristallisierte sich heraus, dass es sinnvoll
ist, die Regeln, die in einem \glos{ids} zum Analysieren des Netzverkehres
verwendet werden, anzupassen. Hierzu haben wir jedes \glos{exploit}, dass im
\f-System verfügbar ist, gesendet, so dass es von einem
\glos{ids} analysiert worden ist. Aus dem, was das \glos{ids} erkannt hatte 
und dem aktuellen Regelsatz, konnten wir ableiten welche Regeln welche
Meldungen generierten. 

Dadurch konnten wir für die im \glos{msf} enthaltenen Angriffe die
beste Konfiguration finden, so dass die False-Positive-Rate im
Verhältnis zu den erkannten Angriffen bei etwa 1:9 liegt. 

\subsubsection{KI}
Es wurden zwischen verschiedene Umsetzungen von \acr{ki}-Methoden
dargestellt, sowie eine in den Ausblick gestellte. Die erste Methode
soll es in \enquote{gray box}-Szenarien ermöglichen Pläne zu
erstellen. Diese Methode hat den Nachteil, dass viel Wissen zu Anfang
bereit stehen muss.  Auch \enquote{re-planning} ist in unbekannten
Topologien nicht einfach möglich. Das Sichtfeld der Angreifer ist
meist ein, bis zwei Pivothosts entfernt. Deshalb kann ein Planer
meist nur einen \enquote{Hop} im Netz planen. Eine weitere Schwierigkeit ist
das Erfassen eines Ziels. Ist das Ziel ein Host, hat der Planer kein
Problem, geben des Vorwissens. Es gibt aber auch weichere Ziele, die
nicht direkt abgebildet werden können. Beispielsweise: der Angreifer
möchte möglichst viele Nutzerdaten sammeln.  Hier ist die Frage a) was
sind viele und b) was sind Nutzdaten.  Des Weiteren wird für die
Verwendung von numerischen Größen ein \enquote{metrischer} Planer
benötigt. Es gibt aber (unseres Wissens nach) keinen Planer der
\enquote{contingent metric planning} unterstützt.

Wir denken, dass die Host Vorhersage zusammen mit der geplanten
\enquote{reinforcement learning} Komponente ein dynamischeres Tool
ermöglicht. Die anzugreifenden Hosts werden anhand des NMAP Bildes und
des Neuronalen Netzes bestimmt. Die Folgeaktionen anhand der
\enquote{loudness} der Aktionen und der \enquote{reinforcement learning}
Komponente.


\section{Framework entwickeln}

Eine der Anforderungen an das \f-System ist ein modularisierter Aufbau,
um die Verwendbarkeit und Erweiterbarkeit zu verbessern, für mehr
Informationen siehe Kapitel~\ref{chp:objectives-functions} auf Seite
\pageref{chp:objectives-functions}.

Wie im Kapitel~\ref{chp:execution} auf Seite~\pageref{chp:execution} genauer
beschrieben wird, ist diese Anforderung im \f-System durch verschiedene
Methoden umgesetzt worden. Durch die Aufteilung der \f-Core Decision,
Knowledge und Action können neue Module einfach in den \f-Core integriert
werden oder bestehende Module ausgetauscht werden. Dies ermöglicht
es den Funktionsumfang des Systems einfach zu erweitern und auf die eigenen
Bedürfnisse anzupassen. Genauere Informationen zum \f-Core können im
Abschnitt~\ref{sec:core} auf Seite~\pageref{sec:core} gefunden werden.

Die \acr{gui} des \f-Systems ist auch nicht direkt im \f-Core integriert,
sondern ist über \glos{xmlrpc} vom \f-Core entkoppelt. Über die \acr{gui}
werden \glos{xmlrpc}-Requests an den \f-Core abgesetzt, die dort erst von dem
\glos{xmlrpc}-Server entgegengenommen werden und anschließend von der
entsprechenden Knowledge, Action- oder Decision-Komponente bearbeitet werden.
Anschließend wird das Ergebnis wieder mittels \glos{xmlrpc} an die \acr{gui}
gesendet.

Dies ermöglicht es, den \f-Core mit einer beliebigen \acr{gui}
anzusprechen, wenn eine \glos{xmlrpc}"=Anbindung bereit gestellt werden kann.
Als Referenzgui wird auf eine \glos{rails}-Webanwendung
zurückgegriffen. Bei dieser Webanwendung, dem C\&C-Server, wurde die
Kommunikation mit \f-Core in zwei Schritten implementiert. Die
\glos{rails}-Models, der Pendant zu den Knowledge-Komponenten,
wurden mit einer direkten Anbindung zur \f-Knowledge erweitert,
während für Decision- und Actionkomponenten über abgesetze
\glos{xmlrpc}-Commands angesprochen werden. Genauere Informationen zu
der Referenzgui sind im Abschnitt~\ref{sec:candc} auf
Seite~\pageref{sec:candc} zufinden. 

Als Angriffskomponente wird beim \f-Systems auf \acr{msf} zurückgegriffen.
\acr{msf} wird über \acr{msfdrbd} und \glos{drb} im \f-Core bereit gestellt. 
\acr{msfdrbd} wird im Abschnitt~\ref{sub_sec:msfdrbd} auf 
Seite~\pageref{sub_sec:msfdrbd} im Detail beschrieben.  

\section{Auditor Assistance}

Wie anfangs im Abschnitt~\ref{sec:motivation:scenario} auf
Seite~\pageref{sec:motivation:scenario} beschrieben wurde, soll das \f-System
von Netz-Auditern zum Testen von Rechnernetzen und \acr{ids} verwendet werden
können. Weitere Informationen zum gedachten Anwendungsbereich können auch in
der Veröffentlichung~\cite{fidiuspaper} über das Projekt nachgelesen werden.

Beim \f-System besitzt der Benutzer, \zB ein Administrator der eine
Risikoanalyse für sein Rechnernetzt durchführen möchte, die Möglichkeit
Hosts in diesem System anzugreifen. Er kann entweder selbst bestimmen
welcher Host angegriffen werden soll oder sich vom \f-System ein
Angriffsziel vorschlagen lassen. 

Wenn vom \f-System ein Host vorgeschlagen werden soll, wird über ein
neuronales Netz ein Host ausgewählt. Hierbei wird anhand der vorhandenen
Daten aus der Knowledgebase eine Bewertung der Hosts vorgenommen. Kriterien
sind \zB die Services auf dem Hosts oder die bekannten \glospl{interface}
des Hosts. Wenn ein Host viele Services bereitstellt, so ist es
wahrscheinlicher, dass der Host auch über interessante Daten verfügt wodurch
er ein interessantes Angriffsziel zum Kompromittieren wäre. Sollte er über
weitere Interfaces verfügen, ist der Host eine interessanter Ausgangspunkt
für sog. Pivoting-Angriffe.

Mit einem solchen System kann der Benutzer nun Schrittweise das Rechnernetz
unter seine Kontrolle bringen, ohne sich selbst mit den vorhandenen
Schwachstellen der jeweiligen Hosts auseinandersetzen zu müssen.

\section{Reduzierung der Rate der False-Positives}

Durch das automatische Erzeugen von maliziösen und nicht maliziösen
Netzverkehr kann unterschieden werden, welche Meldungen des IDS als
False-Positive zu werden ist und welche nicht. Da wir mit dem Snorter
ebenfalls automatisch den Regelsatz für Snort anpassen können, können
wir automatisiert herausfinden, welche Regeln für False-Positives
verantwortlich sind. Hierdurch ist es möglich den optimale Regelsatz
für Snort zu ermitteln und dadurch auf Dauer die Anzahl der
False-Positives zu reduzieren. 


