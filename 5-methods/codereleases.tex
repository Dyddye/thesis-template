\section{Git und GitHub}
\authors{\DM}{\DE \and \WF \and \LM \and \MW \and \JF}

\glos{git} ist ein verteiltes Versionskontrollsystem, welches insbesondere das
non-lineare Entwickeln mit einem effizienten \enquote{Branching} und
\enquote{Merging} unterstützt\footnote{siehe \zB
  \url{http://git-scm.com/about}}. Im Gegensatz zu \acr{svn}, welches wir
im ersten Projektjahr verwendet haben, ist ein zentraler Server zwar nicht
nötig, erleichtert aber die Synchronisation unter den Entwicklern. Auch gibt
es bei \glos{git} keine Semantik für \textit{den} zentralen Server; jedes Repository
ist gleichwertig und kann beliebige \enquote{Remotes} haben. Dabei handelt es
sich um Zeiger auf Repositories an anderen Stellen auf demselben, oder aber
auch auf Hosts im Netz, die mit einem für das jeweilige Repository eindeutigem
Namen identifiziert werden. Klont man ein Repository, so hat dieser Klon mit
\textit{origin} (also \enquote{Ursprung}) bereits einen Remote. Nach Konvention
haben die \textit{origin}-Remotes eine besondere Semantik und erfüllen einen
ähnlichen (zentralisierenden) Zweck wie \acr{svn}-Repositories.\footnote{wie
gesagt, alle Repositories sind dennoch gleichwertig und prinzipiell
untereinander austauschbar}

Im \f-Projekt wurde auf dem Host
\textit{intern.fidius.informatik.uni-bremen.de} (oder kurz \textit{\enquote{intern}})
für jedes (Teil-) Projekt ein solcher Remote eingerichtet. Einzelne Entwickler
können sich so recht einfach mit anderen synchronisieren, indem sie ihre
Änderungen auf \textit{intern} ein- bzw. Änderungen von dort auschecken. Diese
Vorgehensweise ähnelt sehr der von \acr{svn}, hat aber eine Reihe von
Vorteilen.

\begin{itemize}
  \item Neben dem einfachen Anlegen und Zusammenführen von Branches, erlaubt es
      \glos{git} auch lokal, ohne Zugriff auf die Remotes zu arbeiten. Unter anderem
      liegt hierin auch begründet, dass \glos{git} nicht nur subjektiv schneller
      arbeitet.
  \item Das Verwenden weiterer Remotes erleichtert die Veröffentlichung
      (dazu mehr in Abschnitt~\ref{sec:publishing})
\end{itemize}

Wie oben schon kurz angedeutet, war die Entwicklung unabhängiger Komponenten
bereits bei Einrichtung \enquote{des} \glos{git}-Servers auf dem Host \textit{intern}
geplant. Wir standen somit vor der Wahl, all diese Komponenten in einem
einzigem Repository zu verwalten, oder aber für die jeweiligen Komponenten bei
Bedarf ein eigenes Repository anzulegen. Wir haben uns für den zweiten Weg entschieden,
da sich einerseits der Aufwand zum Erstellen eines Git-Repositories in Grenzen hält,
und wir andererseits an sehr verschiedenen Teilprojekten arbeiten wollen, bei denen
es mehr Sinn ergibt, diese auch physisch zu trennen.

Im Hinblick auf Veröffentlichungen Bedarf es geeigneter Plattformen. Das noch
recht junge \glos{git}-Ökosystem\footnote{vgl. \url{http://git.or.cz/index.html\#tools};
Linus Torvalds hat 2005 damit begonnen, den Linux-Kernel mit \glos{git} zu verwalten}
hat sich mit GitHub\footnote{\url{https://github.com}} und
Gitorious\footnote{\url{http://gitorious.org/}} zwei (relativ) bekannte
Repository-Hosting-Services herausgebildet. Dass wir unseren Code schließlich
bei GitHub veröffentlichen würden -- und nicht \zB bei SourceForge oder Google-Code --,
war suggestiv bereits dadurch entschieden worden, dass unsere Betreuer dort bereits
einen \enquote{fidius}-Account registrierten\footnote{\url{https://github.com/fidius}}.

Als bei GitHub kostenfrei registrierter Benutzer bekommt man ein kleines
Speicher-Kontingent von 300\,MB und kann darin unbegrenzt (öffentliche)
Repositories erstellen. Zu jedem Projekt gibt es -- neben der reinen
Code-Verwaltung -- einen Bug- und Issue-Tracker sowie ein
Wiki. Sollte also in absehbarer Zeit die Projekt-interne Infrastruktur
abgeschaltet werden, ließen sich mit geringem Aufwand die Inhalte
transferieren und damit retten.


\section{Ruby}
\authors{\DM}{\DE \and \LM \and \MW \and \JF}

Bald nach dem Projektwochenende stand fest, dass wir unsere Programme in der
Programmiersprache Ruby\footnote{siehe \url{http://www.ruby-lang.org}}
implementieren wollen. Diese Entscheidung hing vor allem von zwei Einflüssen
ab:

Einerseits hatten (fast) alle Projektmitglieder ein mehr oder weniger fundiertes
Wissen über diese Sprache: Im ersten Projektjahr wurden bereits einige kleine
Helfer in Ruby entwickelt. Andere konnten sich dieses Wissen schnell aneignen,
da man Ruby durchaus als einsteigerfreundliche Sprache bezeichnen kann.

Als Ziel stellten wir uns auf der anderen Seite eine Web-Anwendung vor. Da ein
großer Teil der Mitglieder von \f bereits die Veranstaltung \enquote{Agile
Webentwicklung} besuchte\footnote{siehe \uA \url{http://www.tzi.de/~cabo/awe09},
\url{http://www.tzi.de/~cabo/awe10}} (oder dies in Planung hatte), war sofort klar, dass es sich
dabei um eine \glos{rails}-Anwendung handeln würde. Offensichtlich sind dafür
Ruby-Kenntnisse erforderlich.

Um schließlich auch weitere angedachte Komponenten problemlos als Gem zu
veröffentlichen (siehe nächster Abschnitt) und so in andere Komponenten zu
integrieren, bot sich an, auch diese in Ruby zu implementieren.

\section{RubyGems}
\authors{\DM}{\MW \and \JF}

Wie für viele andere Programmiersprachen gibt es auch für Ruby ein zentrales
Repository namens \textit{RubyGems} mit Erweiterungen bzw.
Bibliotheken. RubyGems folgt damit ein bisschen der Tradition, die mit CTAN~(\TeX)
und CPAN~(Perl) begonnen hat, und später auch von EasyInstall~(Python) und
PEAR~(PHP) fortgesetzt wurde. Im Hinblick auf eventuelle Veröffentlichungen
bedeutet dies zumindest eine Vereinfachung bei der Verteilung von
eigenen Entwicklungen, da die Infrastruktur dazu bereits steht und sich
auch durchgesetzt hat.\footnote{vgl. offizielle Ankündigungen:
\url{http://update.gemcutter.org/2009/10/26/transition.html} und
\url{http://update.gemcutter.org/2010/02/20/rubygems-org-move-complete.html}}

Um nun \textit{Gems} (also Ruby-Pakete) zu erstellen, gibt es verschiedene
Möglichkeiten. Neben der manuellen Methode\footnote{nach Spezifikation,
\url{http://docs.rubygems.org/read/chapter/20}}, wurden mehrere Gems entwickelt,
die diesen Prozess vereinfachen. Herauszunehmen ist hier das
\textit{Bundler}-Gem\footnote{\url{http://gembundler.com/}}, da es nicht nur
das Grundgerüst für ein RubyGem erstellen kann, sondern für dieses auch gleich
ein \glos{git}-Repository erstellt und Methoden erzeugt, die eine Veröffentlichung
extrem vereinfachen (siehe Abb.~XXX).

\section{Veröffentlichungen}
\label{sec:publishing}

Das Veröffentlichen unseres Codes geschieht in einigen wenigen Schritten. Wir
nutzen dazu, wie beschrieben, \glos{git} zur Code-Verwaltung und neben unserem eigenen
Server GitHub als Hosting-Dienst.

In Abbildung~\ref{fig:release} ist das prinzipielle Vorgehen in neun Schritten
festgehalten. Die Notation darin ist UML-Sequenzdiagrammen nachempfunden; die
Aktivierungsbalken kennzeichnen die Lebenszeit eines Repositories bzw. eines
Branches darin und bei den Objekten handelt es sich um den physischen Besitzer
des Repositories. Dabei steht \texttt{\$user} einzeln für einen lokalen Benutzer
und mit \texttt{github/}-Präfix für den GitHub-Account dieses Benutzers. Analog
bezieht sich \texttt{github/fidius} auf unseren \f-Account und
\texttt{intern.fidius} auf unseren eigenen \glos{git}-Server.

Die eigentliche Veröffentlichung passiert nun in den folgenden Schritten:

\begin{enumerate}
  \item Auf \textit{intern} wird ein Repository für ein Unterprojekt erzeugt.
  \item Die Entwickler, die an diesem Projekt arbeiten, klonen das Repository.
  \item Auf GitHub wird ein \enquote{offizielles} Projekt angelegt, dass
  \item von einem (oder mehreren) Entwickler ebenfalls auf GitHub \textit{geforkt}
      wird.
\end{enumerate}

Bei einem \textit{Fork} handelt es sich um eine Fortführung des Branching- und
Merging-Prozesses von \glos{git} auf die Web-Oberfläche von GitHub. Der Forkende
erstellt hier keine 1:1-Kopie des Urspungs-Repositories, sondern erzeugt im
Wesentlichen ein neues GitHub-Projekt mit einem Zeiger auf den Ursprung. So
bleibt die vollständige Versionsgeschichte mit allen Commits erhalten, und ein
späterer Rückfluss von eigenen Commits bleibt möglich.

\begin{enumerate}[resume]
  \item Das geforkte Repository wird bei mindestens einem Entwickler als Remote
      hinzugefügt. Der Name (in der Abbildung \enquote{github}) ist dabei frei
      wählbar.
\end{enumerate}

Bisher sind alle Schritte nur einmal pro (Unter-) Projekt durchzuführen. Schritte
6--9 sollten hingegen regelmäßig durchgeführt werden:

\begin{enumerate}[resume]
  \item Die Entwickler entwickeln ihr Projekt und bereiten einen Release vor.
      Dazu gehören auch ein sinnvoller Grad an Dokumentation und natürlich auch
      das Vorhandensein von Tests.
  \item Wann immer der Code ein Qualitätslevel erreicht hat, den man der
      Öffentlichkeit bereits präsentieren kann, sollte dieser in das
      GitHub-Repository der Entwickler eingecheckt werden.
  \item Sobalt ein offizieller Release getätigt werden soll, wird ein so genannter
      \enquote{Pull Request} erstellt. Damit signalisiert man dem Eigentümer
      des Ursprungs-Repositories, dass eigener Code mit dem Ursprungscode
      zusammengeführt werden soll.
  \item Im Projektkontext sollte neben dem eigentlichen Pull-Request auch der
      persönliche Kontakt gesucht werden, damit eine Bearbeitung schnell vollzogen
      wird. Zu dieser Bearbeitung gehört das Markieren des Codes mit einer
      Versionsnummer, die Bereitstellung von Ankündigungen auf der Projekt-Homepage
      und in entprechenden Mailing-Listen\footnote{wie Full Disclosure,
      \url{http://seclists.org/fulldisclosure/}}.
\end{enumerate}


\begin{figure}
  \includegraphics[width=\linewidth]{images/release-workflow}
  \caption{Schema des Veröffentlichungsvorgangs}
  \label{fig:release}
\end{figure}

