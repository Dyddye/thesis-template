\section{Snortor}
\label{snortor}
\authors{\BK \and \DE \and \DK}{\LM \and \MW}

Das Gem \textit{Snortor} wurde entwickelt, um ein Tool zu haben, das erkennen
kann, welche Regeln des NIDS Snort welche Angriffe erkennen und
umgekehrt, welche Angriffe von welchen Snort-Regeln erkannt werden.

Hintergrund hierzu ist, dass wir nach einem Weg gesucht haben,
mögliche \glospl{exploit} danach zu bewerten, wie viele \glspl{glos:idmef-event} bei der
Ausführung des Angriffes getriggert werden. Je weniger Regeln den
Angriff erkennen, desto besser ist der \glos{exploit} geeignet, um mit
möglichst wenig Auffälligkeit in einen Host einzudringen.

Zusammen mit der EvasionDB, welche alle erzeugten Events zu einem
Angriff zuordnen kann, kann der Snortor einen Datensatz erzeugen, aus
dem hervor geht, welche \glospl{exploit}, welche Events im \gls{glos:ids}
erzeugen. So kann man bei späteren Angriffen entweder einem Menschen
bei der Auswahl der \glospl{exploit} aufgrund dieser Datenbasis Empfehlungen
aussprechen oder \glospl{exploit} für eine KI bewerten.

Eine weitere Intention, mit der der Snortor geschrieben worden ist,
ist dass dieser mit der EvasionDB zusammen automatisiert testen kann,
welche Zusammenstellung von Snort-Regeln die \glospl{exploit}, die im
\acr{msf} hinterlegt sind am zuverlässigsten erkennt. Dabei
sollte der Regelsatz möglichst klein gehalten werden, um die
Auslastung des analysierenden Systems minimal zu halten.

Der Begriff Snortor ist Synonym für die \acr{ids}-Autokonfiguration
(Abschnitt~\ref{ids-autoconfig}) geworden. Im Anhang~\ref{snortor-usage}
kann nachgelesen werden, wie Snortor in \acr{msf} verwendet werden kann.

\subsection{IDS-Autokonfiguration}
\label{ids-autoconfig}

Für die automatische Konfiguration von Snort-Regeln werden folgende
Komponenten verwendet:

\begin{itemize}
  \item Snortor
  \item Genetischer Algorithmus
  \item Autopwner
  \item Generierung von False-Positives
\end{itemize}

Das Verfahren basiert auf der Idee, dass eine Konfiguration von
Snort-Regeln dann gut ist, wenn sie möglichst viele Angriffe erkennt
und möglichst wenig False-Positives erzeugt. Dieser Ansatz wird
allerdings aus drei Gründen nicht unbedingt eine
optimale Konfiguration finden:

\begin{enumerate}
  \item Erzeugte Events hängen vom Zielnetz ab
  \item Genetische Algorithmen sind ein statistisches
    Optimierungsverfahren (siehe \cite{mitchel}).
  \item Anzahl der \glospl{exploit} und False-Positives ist begrenzt
\end{enumerate}

Dennoch lässt sich dieser Ansatz verwenden, um Anzahl
\textit{bekannter} False-Positives zu reduzieren. Es wird dabei
folgendermaßen vorgegangen:

\begin{enumerate}
  \item Genetischer Algorithmus gibt randomisierten Bit-String vor
  \item Snortregeln auf Basis eines Bits-Strings aktivieren
  \item Angriffe mit dem Autopwner durchführen
  \item Erzeugte \acr{idmef}-Events abholen
  \item False-Positives erzeugen
  \item Erzeugte \glspl{glos:idmef-event} abholen
  \item Ergebnis der Evaluierung dem Genetischen Algorithmus melden
    und von vorne beginnen
\end{enumerate}

Um zu bestimmen, ob eine Konfiguration \enquote{gut} ist, wird das
Verhältnis zwischen erkannten Angriffen und erkannten False-Positives
gebildet:

\[
  f(\text{snort\_config}) = 
    \frac{\text{recognized\_exploits}}{\text{false\_positives}}
\]

Um der \enquote{Severity} Rechnung zu tragen wurde eine Gewichtung
eingeführt:
\begin{itemize}
  \item low=3
  \item medium=6
  \item hight=9
\end{itemize}

Im Folgenden soll unsere Optimierung der Snort-Regeln mit genetischen
Algorithmen erläutert werden.

\subsection{Optimierung der Snort-Regeln}
Wie beschrieben, sollen die Snort-Regeln so optimiert werden,
dass möglichst wenig False-Positives erkannt werden und
möglichst viele Angriffe. Wir haben uns für Genetische
Algorithmen entschieden da diese sich gut eignen, wenn
die Hypothesen komplex sind \cite{mitchel}.

Eine Hypothese ist, dass ein bestimmter Bit-Vektor aus Regeln
die \enquote{beste} Konfiguration darstellt. In einem Bit-Vektor
stellt eine \textit{1} eine aktive Regel dar und eine \textit{0}
eine nicht aktive. Die \enquote{Güte} einer solchen
Hypothese ist durch eine Fitness-Funktion beschrieben.
In unserem Fall dem Verhältnis von Angriff- zu False-Positive-Ratio:

\[
  \mathrm{fitness}(x) =
    \frac{\text{recognized\_exploits}}{\text{false\_positives}}
    \qquad\text{mit einem Bitvektor $x$.}
\]

Ein prototypischer Genetischer Algorithmus:

\begin{lstlisting}[language={},mathescape=true,
  caption={Prototypischer Genetischer Algorithmus frei nach \cite{mitchel}}]
  Optimize($stop$, $p$, $k$):
    $stop$: Ein Stop-Kriterium. Dies kann ein Schwellwert der Fitness sein oder
          eine maximale Anzahl von Iterationen
    $p$: Die Größe der Population oder die Anzahl der Hypothesen.
    $k$: Anzahl der besten betrachteten Hypothesen.

    1) Erzeuge eine initiale Population $P$ durch randomisiertes Erzeugen von $p$
       Bit-Vektoren (Hypothesen)

    2) Berechne für jede Hypothese $h\in P$ die Fittness.

    3) WHILE !$stop$

       3.1) Wähle die $k$ besten Hypothesen.
       3.2) Kombiniere die $k$ besten Hypothesen
       3.3) Wähle randomisiert Hypothesen aus den $k$ besten und mutiere diese.
       3.4) Berechne für jede Hypothese $h \in P$ die Fittness.

    4) return beste Hypothese
\end{lstlisting}

Zunächst wird eine initiale Population (eine Menge von Hypothesen)
generiert. Dies sind in unserem Fall Hypothesen, in denen
die Snort-Regeln randomisert aktiv gesetzt werden. In unserem
Fall ist die Größe der Population auf \textit{zehn} Hypothesen gesetzt worden.
Wird die Fitness berechnet, wird der Bit-Vektor in
Snort Regeln übersetzt, der daraus resultierende Regelsatz in Snort
eingespielt und es werden Angriffe wie False-Positives erzeugt.
Die daraus resultierenden \glspl{glos:idmef-event} werden dann zur Berechnung
der Fitness genutzt.

Bei der Kombination von Bit-Vektoren nutzen wir \enquote{Single-Point
crossover} \cite{mitchel}. Bei diesem Verfahren werden aus zwei
Bit-Vektoren zwei neue erzeugt. Dazu werden die Vektoren in der
Mitte geteilt und neu kombiniert (s. Abb.~\ref{fig:single_point_crossover}).

\begin{figure}
 \centering
 \input{images/genetic-algorithm.tex}
 \caption{Single Point Crossover. \cite{mitchel}}
 \label{fig:single_point_crossover}
\end{figure}

Bei der Mutation wird ein Bit an einer zufällig gewählten Position
gekippt.

Durch die Nutzung dieser Methode ist es möglich, Snort-Regel-Konfigurationen
zu verbessern. Es müssen aber noch genauere Versuche erfolgen. Des Weiteren
sollte der Einfluss verschiedener Optimierungsverfahren getestet werden.

