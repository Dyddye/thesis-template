\section{CVE-DB}
\label{sec:cve-db}
\authors{\AB \and \JF}{\DE \and \LM \and \MW}

Um Angriffe auf Rechnernetze und einzelne Hosts durchführen zu können,
müssen zunächst die Schwachstellen des Systems ermittelt werden. Dabei
liegt es nahe, Systeme auf bereits bekannte Schwachstellen zu
untersuchen. Die bekannten Schwachstellen werden in öffentlich
zugänglichen Datenbanken wie der
\acr{nvd}\footnote{\url{http://nvd.nist.gov/}} verwaltet. Jede
Schwachstelle bekommt dabei eine eindeutige \acr{cve}-Nummer
zugewiesen, anhand derer sie identifiziert wird. Um Systeme auf
Schwachstellen zu untersuchen gibt es Schwachstellenscanner wie das im
Folgenden beschriebene OpenVAS\footnote{\url{http://www.openvas.org/},
siehe dazu auch die Referatsausarbeitung~\ref{compositions:openvas},
\nameref{compositions:openvas}.} (die quelloffene Variante des Scanners
Nessus\footnote{\url{http://www.tenable.com/products/nessus}}), die
Systeme automatisiert untersuchen und einen Bericht über die
ermittelten Schwachstellen liefern.

Um in dem \f-System Zugriff auf \acr{cve}-Einträge zu erhalten,
wurde das \textit{fidius-cvedb} Gem entwickelt. Dadurch sollen dem
Angreifer passend zu einem vorher gescannten Zielsystem mögliche
Schwachstellen aufgezeigt werden. Im \f-System wird \glos{nmap}
zum Scannen der Ziele verwendet und die Informationen zur Version
genutzt, um zu einem Dienst passende \acr{nvd}-Einträge zu finden (mehr dazu
im Abschnitt~\ref{sec:use-in-fidius}).

\subsection{OpenVAS}
\label{sec:openvas}

OpenVAS ist ein freier Schwachstellenscanner, der zum einen dazu in der Lage
ist, ein Rechnernetz auf mögliche Schwachstellen zu testen, aber zum
anderen auch zu gefundenen Schwachstellen die passenden Einträge aus
einer \acr{cve}-Datenbank anzeigen kann.
%Neu:
Bei der Ermittlung von
Schwachstellen verfolgt OpenVAS ein anderes Konzept als das im
\f-System eingesetzte \acr{msf}. Die zu prüfenden Systeme werden
nicht aktiv angegriffen, um vorhandene Schwachstellen
auszunutzen. Stattdessen prüft ein Schwachstellentest in OpenVAS die
Versionsnummern der laufenden Dienste und Dateien und meldet eine
Sicherheitslücke, wenn diese Version als angreifbar gilt.

OpenVAS bietet eine eigene Bibliothek (\textit{libopenvas}) an, mit der
Aktionen, wie Scanvorgänge oder das Testen einzelner Dienste auf
bekannte Schwachstellen durch Überprüfung der verwendeten Version,
gesteuert werden können. Im \f-Kontext ist die Verwendung der
Bibliothek jedoch nicht praktikabel, da sie selbst nicht die
Funktionalität von OpenVAS bereitstellt, sondern eine laufende
OpenVAS-Anwendung bestehend aus Client und Server benötigt, die dann
gesteuert wird.

Mit OpenVAS ist es nicht möglich, Schwachstellen eines Hosts von außen
zu ermitteln. Daher basieren die meisten Schwachstellentests auf der
Voraussetzung, dass es Logindaten für die zu überprüfenden Systeme
gibt. Für \f werden aber vor allem Schwachstellen von Diensten
benötigt, die ein Eindringen von außen, ohne bereits Anmeldedaten zu
haben, möglich machen.

Um OpenVAS dennoch im \f-Kontext verwenden zu können, wäre es möglich
gewesen, mit OpenVAS Schwachstellen zu suchen und im Anschluss über
die \acr{cve}-Nummer einen passenden Exploit in \acr{msf} zu
finden. Dies scheitert jedoch daran, dass die \acr{cve}-Nummern, die
OpenVAS liefert, häufig nicht in den Exploits von \acr{msf}
aufzufinden sind. Zum einen liegt es daran, dass \acr{msf} den
Exploits nicht konsequent die passenden \acr{cve}-Nummern zuweist. Zum
anderen liefert OpenVAS vor allem \acr{cve}-Nummern, bei denen sich
die Schwachstellen erst mit Logindaten auf einem Host ausnutzen
lassen. Daher sind diese Schwachstellen nicht in \acr{msf} verwendbar,
weil das \f-System hier lediglich die Exploits verwendet, die
Schwachstellen von außen ausnutzen können.

Aufgrund dieser gravierenden Nachteile wird im \f-System nicht
OpenVAS zur Suche der \acr{cve}-Nummern verwendet, sondern es werden
Abfragen an eine zuvor lokal erstellte \acr{cve}-Datenbank, wie im
folgenden Abschnitt beschrieben, gestellt.

\subsection{Gem fidius-cvedb}
\label{sec:gem-fidius-cvedb}

Das \textit{fidius-cvedb}-Gem wurde sowohl auf
Github\footnote{\url{https://github.com/fidius/cvedb}}, als auch über
Rubygems\footnote{\url{https://rubygems.org/gems/fidius-cvedb}}
veröffentlicht. Es beinhaltet verschiedene Komponenten, um eine eigene
\acr{cve}-Datenbank auf Basis der \acr{nvd} zu pflegen und in eine
\glos{rails} Anwendung einzubinden:

\begin{center}
  \begin{longtable}{lp{.7\linewidth}}
    \rowcolor{Beige}
      Bestandteile & Funktion \\
    \endhead
      \caption[]{CVE-DB-Gem Bestandteile\\\tabelletbcname}
    \endfoot
      \caption{CVE-DB-Gem Bestandteile\label{tab:execution:cve-db-gem-parts}}
    \endlastfoot
    \acr{xml}-Parser & Die \acr{nvd} stellt \acr{xml} Dateien bereit, die
                        entweder die \acr{cve}-Einträge eines ganzen Jahres oder
                        aktualisierte \acr{cve}-Einträge beinhalten. Diese werden
                        durch den \acr{xml}-Parser eingelesen und über eine
                        Zwischendarstellung schließlich als Rails-Objekte
                        abgespeichert.\\
    MSSB-Parser & Stellt Verknüpfungen zwischen der \acr{mssb} Notation und
                  \acr{cve}-Einträgen her.\\
    \glos{rake}-Tasks & Verschiedene Tasks, um eine \acr{cve}-Datenbank zu
                          initialisieren, updaten, etc. (siehe
                          Tabelle~\ref{tab:execution:cve-db-gem-tasks})\\
    Modelle \& Migrationen & Bilden die \glos{cve}-Einträge auf \glos{rails}-Objekte
                              ab und erstellen ein entsprechendes Datenbankschema.\\
  \end{longtable}
\end{center}

Tabelle~\ref{tab:execution:cve-db-gem-tasks} zeigt die verfügbaren
\glos{rake}-Tasks, die je nach \glos{rails}-Version entweder über symbolische
Links (\glos{rails} niedriger als Version 3) oder \glos{railties} (\glos{rails}
ab Version~3 oder höher) in die Anwendung eingebunden werden.

\begin{center}
  \begin{longtable}{lp{.7\linewidth}}
    \rowcolor{Beige}
      Name & Funktion \\
    \endhead
      \caption[]{CVE-DB-Gem Raketasks\\\tabelletbcname}
    \endfoot
      \caption{CVE-DB-Gem Raketasks\label{tab:execution:cve-db-gem-tasks}}
    \endlastfoot
    nvd:migrate & Erstellt das Datenbankschema.\\
    nvd:initialize &  Initialisiert die Datenbank wobei alle Jahres-\acr{xml}-Dateien
                      runtergeladen und eingelesen werden.\\
    nvd:mscve & Stellt die Verknüpfungen zwischen MSSB und \acr{cve}-Einträgen her.\\
    nvd:update & Aktualisiert die Datenbank anhand der \texttt{modified.xml} der \acr{nvd}.\\
    nvd:drop & Löscht die persönliche \acr{nvd}.\\
    nvd:get[xml\_name] & Lädt die Datei von der \acr{nvd} Seite.\\\pagebreak
    nvd:parse[file\_name] & Liest die heruntergeladene Datei ein und speichert die
                            Inhalte.\\
    nvd:list\_local & Listet die lokalen \acr{xml} Dateien auf.\\
    nvd:list\_remote & Listet die bei der \acr{nvd} verfügbaren \acr{xml} Dateien auf.\\
  \end{longtable}
\end{center}

\subsubsection{XML-Parsing}
\label{sec:xml-parsing}

Um eine Datenbank mit den aktuell verfügbaren \acr{cve}-Einträgen zu
erhalten, greifen wir auf die \acr{nvd} zu. Diese bietet \acr{xml}
Dateien an, in denen \acr{cve}-Einträge einzelner Jahre oder aktuelle
Änderungen an
\acr{cve}-Einträgen\footnote{\url{http://cpe.mitre.org/specification/diagram.html}}
abgerufen werden können. Um an Software und Versionsinformationen zu
gelangen, lesen wir unter anderem die \acr{cpe}-Einträge aus. Diese
liegen in folgender Struktur vor:

\begin{lstlisting}
  cpe:/part:vendor:product:version:update:edition:language
\end{lstlisting}

Am Beispiel eines Eintrages der \acr{nvd}:

\begin{lstlisting}[language=XML]
  <vuln:vulnerable-software-list>
    <vuln:product>cpe:/a:mozilla:firefox:1.5.0.3</vuln:product>
  </vuln:vulnerable-software-list>
\end{lstlisting}

Im Kontext von \f verwenden wir vor allem die Werte \textit{product} und
\textit{version}, um sie mit den durch einen \glos{nmap}-Scan gesammelten
Informationen zu vergleichen und somit passende \acr{cve}-Einträge zu ermitteln.

\subsubsection{Design-Entscheidung: REST vs. ActiveRecord}
\label{sec:design-entsch-rest}

Um im \f-System auf die \acr{cve}-Datenbank zugreifen zu können, stand
eine \glos{rest}
Architektur\footnote{ siehe dazu auch die Dissertation von Roy Thomas
  Fielding \url{http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm}}
oder die direkte Integration mit \glos{active_record}-Modellen zur
Diskussion. Ein Vorteil der ersten Variante wäre eine relativ lose
Kopplung an \f, was jedoch zur Folge gehabt hätte, dass viele
Anfrage-Operationen auch durch entsprechende Antworten abgedeckt
werden müssten. Im Gegensatz dazu stehen durch die Einbindung der
entsprechenden Rails-Modelle in den C\&C-Server
alle \glos{active_record}-Funktionen direkt zur Verfügung. Insbesondere durch
Rails' \texttt{find}-Methode und dessen Derivate (\texttt{find\_by\_x} etc.)
können ohne grossen Aufwand beliebige Abfragen gemacht werden, weshalb
wir uns für diesen Weg entschieden haben. Dennoch wäre ein
\glos{rest}-\glos{interface} für eine eigenständige
\glos{rails}-Anwendung auf Basis der \acr{cve}-DB denkbar. Dies wurde im
Kontext von \f jedoch nicht benötigt und daher auch nicht entwickelt.

\subsubsection{Verwendung in FIDIUS}
\label{sec:use-in-fidius}

Ursprünglich wurde das Ziel verfolgt, anhand der ermittelten \acr{cve}-Nummern
Exploits in Metasploit auszuwählen, die zu den \acr{cve}-Nummern passen. Dazu
gibt es in der Exploit Definition unter Metasploit das Attribut
\textit{References}, in dem ein \acr{cve}-Eintrag referenziert werden kann und
mit dem die gefundenen Nummern verglichen werden können. In der Anwendung hat
sich jedoch schnell herausgestellt, dass die ermittelten Nummern und die im
Exploit eingetragene selten übereinstimmen. Dies liegt unter anderem daran, dass
die durch \glos{nmap} Scans ermittelbaren \acr{cve}-Einträge zu ungenau sind.
Daher werden die Informationen in \f nur zusätzlich zum Scan Ergebnis zur
Verfügung gestellt und nicht zur Auswahl von Exploits verwendet.

Die von \glos{nmap} ermittelten
Informationen \textit{SERVICE} und \textit{VERSION} werden verwendet, um
\acr{cve}-Einträge zu durchsuchen. Nachfolgend ist ein beispielhafter
\glos{nmap}-Scan eines MySQL-Servers abgebildet. Mithilfe eines regulären
Ausdrucks wird die zu dem Service \textit{mysql} gehörige Version
ermittelt.

\begin{console}
  $ nmap -A <zielrechner>
  PORT     STATE SERVICE VERSION
  3306/tcp open  mysql   MySQL 5.1.41-3ubuntu12.10
\end{console} %$

Aus der Version \verb|MySQL 5.1.41-3ubuntu12.10| wird somit ermittelt:

\begin{lstlisting}[numbers=none]
  "MySQL 5.1.41-3ubuntu12.10".scan(/\b\d+\.\d+\S*\b/) #=> ["5.1.41-3ubuntu12.10"]
\end{lstlisting}

Ein Problem bei diesem Verfahren besteht darin, dass die Genauigkeit
davon abhängt, ob der \glos{nmap}-Scan ausreichend Informationen liefern kann
und diese auch in parsierbarer Form angezeigt werden.
Sind keine Versionsinformationen vorhanden, wird ausschließlich
der Name des Services verwendet. Dadurch werden sehr viele \acr{cve}-Einträge
gefunden, die zwar zu dem bereitgestellten Dienst passen, jedoch
nicht zu dessen verwendeter Version.

Ist ein Scan jedoch genau genug und in der Datenbank ein
entsprechender Eintrag vorhanden, stehen dem Benutzer verschiedene
Zusatzinformationen zur Verfügung. Diese umfassen unter anderem eine
Beschreibung der Schwachstelle, die \glos{cvss}-Werte und weiterführende Links
mit Beschreibungen und ggf. vorhandenen \glospl{exploit}.

