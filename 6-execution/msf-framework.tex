\section{Metasploit-Framework}
  \label{sec:msf_framework}
  \authors{\LM}{\HM \and \DE \and \DH}
\subsection{MSF}
  \label{sub_sec:msf}

Zum Ausführen von Angriffen auf Hosts wird auf das \acr{msf}
zurückgegriffen. Das \acr{msf} ist in mehrere Module unterteilt. Unter
anderem \glos{exploit} und \glos{payload}, diese werden miteinander
kombiniert um erfolgreich einen Host anzugreifen und können über Optionen
mit verschiedenen Parametern versehen werde. Bei den \glospl{exploit} und
\glospl{payload} das bestimmte Kombinationen nicht funktionieren, so können
keine Windows-\glospl{exploit} mit Unix-\glospl{payload} kombiniert werden.
Außerdem werden vom verwendeten \glos{exploit} beschränkt, wie groß ein
\glos{payload} sein darf und welche Bytes verwendet werden dürfen, da
bestimmte Bytes als Kontrollzeichen der auszunutzenden Schwachstellen
dienen.

Ein \glos{exploit} bezeichnet dabei Schadcode der eine bestimmte
Sicherheitslücke ausnutzt und so Zugriff auf einen Host ermöglicht. Die
\glospl{exploit} unterscheiden sich anhand der ausgenutzten
Sicherheitslücke und den den anwendbaren \glospl{payload}.

Dem \glos{exploit} wird ein \glos{payload} zugewiesen und bei erfolgreicher
Anwendung des \glospl{exploit} wird anschließend vom \glos{exploit} der
\glos{payload} ausgeführt. Als \glos{payload} wird ein Programm oder
Codestück bezeichnet, dass auf dem anzugreifenden Host ausgeführt werden
soll. Häufig möchte man eine Shell erhalten, da diese als Basis für fast alle
weiteren Aktivitäten dienen kann. Bei dem \acr{msf} wird häufig auf die
\acr{metap}-Shell, siehe~\ref{compositions:meterpreter} Seite
\pageref{compositions:meterpreter}, zurückgegriffen. Genauere Informationen
zu den verschiedenen \glospl{payload} können im Abschnitt
\ref{compositions:msf:payloads} auf Seite \pageref{compositions:msf:payloads}
gefunden werden. Wenn der \glos{exploit} und der \glos{payload} erfolgreich
ausgeführt wurden, wird eine \acr{msf}-Session erzeugt über die der Angreifer
mithilfe einer Shell Aktionen auf dem angegriffen Host ausführen kann.

Über die Optionen des \glospl{exploit} können verschiedene Einstellungen vorgenommen
werden, \uA an welche \acr{ip}-Adresse und \glos{port} der \glos{exploit} gesendet
werden soll und an welche Adresse sich die Session zurückmelden soll. Nachdem
ein \glos{exploit} erfolgreich ausgeführt wurde, wird der \glos{payload}
ausgeführt und anschließend meldet sich der \glos{payload} sich bei \acr{msf}, um
weiteren Code nachzuladen und um auf Befehle zu warten. Diese Anfragen werden von
\glos{multihandler}n entgegengenommen, die auf bestimmte \glospl{interface} und
\glospl{port} lauschen um die Anfragen entgegen zunehmen.

Mit \acr{msf}-Plugins gibt es eine einfache Möglickeit, die
Funktionalität von \acr{msf} zu erweitern. Jedes
\acr{msf}-Plugin wird in einem eigenen Source-File implementiert und kann
dynamisch im \acr{msf} geladen werden.

Da es sich um eigene Source-Files handelt kann \acr{msf} einfach erweitert werden, ohne
das es zu Kompatibilitätsprobleme bei \acr{msf}-Updates kommt. Dies ermöglicht es
weiterhin mit der aktuellen \acr{msf}-Version zu arbeiten, was vorteilhaft ist,
um neue Features und Optionen, \zB aktuelle \glospl{exploit} und \glospl{payload}, zu nutzen.
Außerdem sind unsere Erweiterungen von \acr{msf} abgekoppelt und können
separat zu \acr{msf} veröffentlicht werden.

Mit den \acr{msf}-Plugins kann auf die komplette \acr{msf}-\acr{api}
zurückgegriffen werden, dadurch lassen sich bestehende Methoden von \acr{msf} erweitert oder neue Funktionen zum \acr{msf} hinzufügen.

\subsection{MSF-DRb-Daemon}
\label{sub_sec:msfdrbd}
\authors{\DM}{\LM \and \MW}

Das Design des \acr{msf} hat eine besonders hervorzuhebende Schwäche: Beim
Start lädt es \textit{alle} \glospl{exploit}, \glospl{auxiliary} und sonstige Hilfsmodule.
Der Ruby-Interpreter muss dazu 2 Millionen Zeilen Quellcode aus rund
11.000~Dateien lesen und interpretieren, bevor man überhaupt mit dem Framework
arbeiten kann.\footnote{die Zahlen stellen ein Maximum dar, und schließen \uA
die Dokumentation und Quellcode-Kommentare mit ein} Beim Entwickeln und Testen
von Funktionen rund um das Framework ist dies von Nachteil, da so sehr viel
Zeit für das Laden aufgewandt wird.

Um dieses Problem zu umgehen (und auch um später das Framework auf einem
eigenem Host betreiben zu können), haben wir uns dazu entschlossen, das
Framework (bzw. eine Instanz davon) in einem separaten Hintergrundprozess zu
verwalten und via \acr{drb} anzubinden (der Name \acr{msfdrbd} leitet sich
davon ab).

Einen bereits vom Hersteller vorbereiteten Hintergrund-Server (\textit{Metasploit
XMLRPC daemon}, \enquote{msfrpcd}) haben wir uns ebenfalls angesehen. Die
angebotene \acr{xml}-\acr{rpc}-Schnittstelle schien uns zum einen nicht mächtig
(\textit{jede} von außen aufrufbare Methode muss separat in dieser Komponente
definiert werden) und zum anderen erzeugt die Schnittstelle aufgrund der
\acr{xml}-Natur messbaren Overhead in der Datenübermittlung. Unterschiedliche
Zeichenkodierungen in den verschiedenen Ruby-Versionen, \glos{exploit}-Dateien und
Ergebnis-Daten der \acr{msf}-Methoden verkomplizieren den Umgang mit \acr{xml}-Daten
zusätzlich.

Für unsere Zwecke genügte jedoch eine einfache Anbindung des Frameworks. Im
Idealfall würde die Instanziierung einfach in einem eigenem Prozesse geschehen
und kann danach von anderen, beliebigen (autorisierten) Prozessen benutzt
werden. Die Verwendung von \acr{drb} bietet uns genau diese Fähigkeit. Unser
Daemon erstellt eine Framework-Instanz und stellt sie mit einigen Hilfsmethoden
über \acr{drb} bereit.

Im Hinblick auf die Entwicklung von Erweiterungen (Plugins) für \acr{msf} hat
dieser Ansatz vor allem den Vorteil, auch Plugins zur Laufzeit des Daemons aus
benutzerdefinierten Verzeichnissen zu laden (und entladen). Da hierbei nicht
das vollständige Framework geladen werden muss, beschleunigt das die Entwicklung.
Diese Kapselung erlaubt uns auch, das \glos{msf} um Funktionen zu erweitern,
ohne den Quellcode des Frameworks direkt verändern zu müssen.

\newpage
\subsection{Plugins}
\label{sub_sec:msf_plugins}

\subsubsection{False-Positive-Auxiliaries}
\label{msf-false-positives}
\authors{\BK}{\HM \and \LM \and \DE \and \MW}

Diese \glospl{auxiliary} sind dazu gedacht,
die Reaktion eines \glos{ids} zu testen. Sie enthalten nur den \glos{payload}
auf den \glos{snort} reagiert. Sie
lassen sich nur sinnvoll im Zusammenhang mit der EvasionDB einsetzen,
um zu prüfen, ob die Events tatsächlich erzeugt wurden. Die Namen sind
an die Titel der \acr{idmef}-Events angelehnt. Folgende Auxiliaries sind
erstellt worden:

\begin{itemize}
  \item \texttt{exploit\_jmpcall\_additive\_encoder}
  \item \texttt{web\_server\_exploit\_suspected\_php}
  \item \texttt{netbios\_share\_access}
\end{itemize}

Ein Beispiel für die Ausführung eines solchen Auxiliaries:

\begin{lstlisting}[language={}]
  msf > use auxiliary/ids/false_positive/exploit_jmpcall_additive_encoder
  msf > set RHOST 10.20.20.1
  msf > exploit
  msf auxiliary(exploit_jmpcall_additive_encoder) > exploit
  [*] Auxiliary
  module execution completed
\end{lstlisting}

\subsubsection{Base64-PHP-Meterpreter}
\label{base64-php-meterpreter}
\authors{\BK}{\HM \and \LM \and \DE \and \MW}

Diese Erweiterung sorgt dafür, dass die Befehle des PHP-Meterpreters
mit Base64 kodiert werden \cite{rfc4648}. \glos{snort} besitzt Regeln, die auf Pakete
reagieren, die Funktionsaufrufe des PHP-Meterpreters enthalten. Werden
die Funktionsnamen mit Base64 kodiert, greift keine der Regeln mehr und
es werden keine \glospl{idmef-event} mehr erzeugt.
Der \acr{metap} ist als eigener \glos{payload} realisiert und lässt sich als
Alternative zum normalen PHP-Meterpreter verwenden.

\begin{lstlisting}[language={}]
  msf > set PAYLOAD php/meterpreter_base64/bind_tcp
\end{lstlisting}

Neben einer modifizierten \texttt{data/meterpreter/meterpreter.php} wurde
ebenfalls die Methode \texttt{send\_request} aus
\texttt{lib/rex/post/packet\_dispatcher.rb} so erweitert, dass bestimmte
Funktionen Base64-kodiert werden:

\begin{lstlisting}
  if self.exploit_datastore["METERPRETER::base_encode_64"]
    packet.tlvs.each do |tlv|
      if ["stdapi_fs_ls","stdapi_sys_config_sysinfo","stdapi_fs_getwd","stdapi_sys_config_getuid"].member?(tlv.value)
        tlv.value = Base64.encode64(tlv.value).to_s.gsub("\n","")
      end
    end
  end
\end{lstlisting}

\subsubsection{Lab}
\label{lab}
\authors{\DH}{\LM \and \DE \and \MW}

Das Lab-Plugin bietet die Möglichkeit zur Steuerung von
Virtualisierungssystemen aus dem \gls{acr:msf} heraus. Ebenso ist das
Plugin so Modular aufgebaut, dass eine Erweiterung um weitere
Virtualisierer recht einfach erfolgen kann.

Die Steuerung von Virtualisierern aus dem \acr{msf} erlaubt das vereinfachte
Aufsetzen und Modifizieren von Testumgebungen für verschiedene
Sicherheitstests. So können einzelne Skripte für das \acr{msf} entwickelt
werden, die vor jedem Angriff bestimmte \glspl{acr:vm} starten, den
Angriff ausführen, den Status des virtuellen Servers abfragen, um die
Auswirkungen des Angriffs zu ermitteln. Die \gls{acr:vm} kann dann auf
den Zustand vor dem Angriff zurückgesetzt werden, wenn vor dem Angriff
ein Sicherungspunkt (ein sog. \glos{snapshot}) erstellt wurde. Wie an diesem
Vorgehen zu sehen ist, erleichtert dieses Plugin mittels Automatisierung das
Testen von Angriffen in bestimmten Szenarien.

Das \f-System nutzt für die Testlandschaft wie im
Abschnitt~\ref{sec:test_environment} den Virtualisierer
\glos{qemu}\footnote{\url{http://www.qemu.org}}. \glos{qemu} wird allerdings
standardmäßig vom Lab-Plugin des \acr{msf} nicht unterstützt. So wurde das
Lab-Plugin um den \glos{qemu}-Virtualisierer erweitert. Das Lab-Plugin wird
vom \f-System weniger für automatisierte Sicherheitstest, sondern
in erster Linie zum Testen des \f-Systems verwendet.

\subsubsection{Lab-API}
\label{lab-api}
\authors{\LM}{\HM \and \DE \and \MW}

Standardmäßig unterstützt das Lab-Plugin nur Konsolen-Kommandos um die
\glspl{acr:vm} zu steuern. Dies ist allerdings für unseren Anwendungsfall nicht
ausreichend, da mit den \glspl{acr:vm} die Tests automatisiert werden sollen.
Entsprechend muss es aus unserem System, bzw. für die Tests, möglich sein die
\glspl{acr:vm} zu steuern.

Da das Lab-Plugin die Konsolen-Kommandos nur an Funktionen von Lab
weiterleitet, war es einfach eine \acr{api} mit dem selben Funktionsumfang zu
implementieren. Die Lab-\acr{api} stellt identische Methoden zum Lab-Plugin bereit und
leitet sie auch nur an Lab weiter. Somit handelt es sich bei den beiden Plugins
lediglich um unterschiedliche Aufrufsroutinen für die Lab-Funktionen. Für uns
ermöglicht das Lab-\acr{api}-Plugin, während der Tests die \glspl{acr:vm} automatisch
zu steuern und somit automatisch die benötigte Testumgebungen zu erzeugen.

\subsubsection{MultiHandler-Manager}
\label{multihandler-manager}
\authors{\LM}{\HM \and \DE \and \MW}
Im \acr{msf} werden \glos{multihandler} zum Verwalten und
Entgegennehmen von Sessions verwendet. Normalerweise werden
die \glos{multihandler} automatisch vor der Ausführung eines \glospl{exploit} gestartet,
wenn für den gewählten \glos{payload} ein
\glos{multihandler} benötigt wird. Allerdings soll unser System auch persistente
\glospl{payload} unterstützen, die manuell gestartete \glos{multihandler} benötigen.

Bei persistenten \glospl{payload} handelt es sich um \glospl{payload}, die
sich im kompromittierten Systemen eingehängt haben und bei jedem Start der
Systeme automatisch ausgeführt werden. Wenn nur \glos{multihandler}
verwendetet werden, die beim Ausführen eines \glos{exploit}s gestartet
werden, kann nicht gewährleistet werden, dass immer ein \glos{multihandler}
gestartet ist. Deswegen müssen bei der Verwendung von persistenten
\glospl{payload} weitere \glos{multihandler} gestartet werden

Dies bedeutet also, das im \f-System nicht alle \glos{multihandler}
automatisch gestartet werden, sondern bestimmte auch manuell gestartet und
gesteuert werden müssen. Allerdings werden \glos{multihandler} von
\acr{msf} als \glospl{exploit} gestartet und als Job in \acr{msf} abgelegt. Bei Jobs
handelt es sich um einen Container für verschiedne \acr{msf}-Module die im
Hintergrund weiterlaufen sollen. Verwaltet werden diese von einem Array,
allerdings werden die Jobs aber nur anhand ihres Modultypen bzw. Namen, \zB.
der Name des \glospl{exploit} der sich in diesen Job befindet, identifiziert. Beim
Ausführen von mehreren \glos{multihandler} erhält man dadurch ein Problem, da
der Exploitname jeweils identisch ist und sich der \glos{multihandler} nur über
zusätzliche Informationen, \zB über das verwendete \glos{interface},
unterscheiden lassen. Um an diese Informationen zu gelangen muss aber
umständlich im Job-Container gesucht werden. An dieser Stelle soll dieses
Plugin zum einsatzen kommen, in dem es eine einfache \acr{api} zur Steuerung
der \glos{multihandler} zur Verfügung stellt.

Zum Steuern der \glos{multihandler} wird mindestens die Funktionalität benötigt,
\glos{multihandler} zu starten, zu stoppen und laufende \glos{multihandler}
anzuzeigen. Die Methoden von \acr{msf} ermöglichen zwar das Absetzen dieser
Befehle, allerdings nur sehr umständlich und hier setzt das
\glos{multihandler}-Plugin an, in dem für die Steuerung von
\glos{multihandler}n Shourtcuts auf Basis der \acr{msf}-Methoden zur Verfügung
gestellt werden.

Ziel ist es dabei die jeweiligen Befehle mit einem einzelnen Methodenaufruf
ausführen zu können und nur die Parameter angeben zu müssen die für
\glos{multihandler} relevant sind. Zum Starten und Stoppen von
\glos{multihandler} konnte im Wesentlichen auf \acr{msf}-Methoden
zurückgegriffen werden und es wurde nur bei den benötigten Parametern
optimiert. Der Aufwand, aller \glos{multihandler} aufzulisten, war schon
höher, da hier als erstes die entsprechenden Jobs, die einen
\glos{multihandler} enthalten, gefunden werden mussten und anschließend der
Job-Container nach den für \glos{multihandler} relevanten Informationen
durchsucht wurden.

Diese Funktion ist auch die hauptsächliche Arbeitserleichterung die vom
\glos{multihandler}-Plugin geliert wird. Letztendlich erweitert das
\glos{multihandler}-Plugin \acr{msf} um folgende Methoden:

\begin{itemize}
  \item \texttt{get\_running\_multihandler}
  \item \texttt{stop\_multihandler}
  \item \texttt{start\_multihandler}
\end{itemize}

\subsection{Meterpreter-Skripte}
\label{sec:msf:scripts}

\subsubsection{Ettercap}
\authors{\DH}{\LM \and \DE \and \MW \and \JF}

Ettercap\footnote{\url{http://ettercap.sourceforge.net}} ist ein
Snifferprogramm mit dem auch \glos{ManInTheMiddle}-Angriffe möglich sind.
Ettercap ist auf vielen Plattformen wie Linux, Windows, Mac~OS~X \uA
lauffähig. Darüber hinaus wird Sniffing auf IP- wie auch auf ARP-Basis,
Echtzeitkontrolle über Verbindungen selbst in geswitchten Netzen,
inhaltsbezogene Filterung und aktive wie auch passive Analysen von einzelnen
Hosts und ganzen Netzen unterstützt. Weiter ist es mit Ettercap möglich,
selbst verschlüsselte Verbindungen zu belauschen, da Pakete bereits auf
Schicht~2 (\acr{arp}) im OSI-Modell abgehört werden können.

Ettercap ist für das \f-Projekt deswegen so interessant, da \zB mit
Hilfe von \glos{ManInTheMiddle}-Angriffen (DNS-Poisoning) potentielle
Opfer auf eine manipulierte Webseite umgeleitet und dadurch vom
\f-System übernommen werden können. Mithilfe der inhaltsbezogenen
Filterung lassen sich \acr{http}-Pakete so manipulieren, dass der
angegriffene Rechner von einer \acr{http}-Anfrage infiziert wird. Dies
geschieht indem die \acr{http}-Anfrage durch zusätzlichen Schadcode
erweitert wird, so dass der angegriffene Rechner kompromittiert wird.

Diese Anwendung wurde nun mit einer eigenen Installationsroutine
ausgestattet, so dass eine versteckte Installation ohne benötigte
Nutzerinteraktion möglich ist. Hinzugekommen ist eine
\acr{metap}-Erweiterung, die die benötigten Laufzeit-Bibliotheken für
Ettercap und die Ettercap-Installationsroutine im Hintergrund auf das
gekaperte System lädt, sowie im Anschluss das gekaperte System für den
Einsatz für Ettercap vorbereitet. Nach erfolgter Ettercap-Installation
bietet die \acr{metap}-Erweiterung verschiedene Kommandos zur
Fernsteuerung von Ettercap an.

\subsubsection{Firewall-Skript}
\authors{\LM}{\WF \and \MW \and \JF}

Relativ früh wurde sich damit auseinander gesetzt, wie am besten Firewalls
auf kompromittierten Hosts umgangen werden können. Firewalls können den
Netzverkehr blockieren und dadurch verhindern, dass Befehle an die
\acr{msf}-Sessions gesendet oder von diese Daten an \acr{msf} gesendet werden
können. Am einfachsten kann eine Firewall durch das Beenden umgangen werden,
allerdings erhöht eine deaktivierte Firewall auch die Wahrscheinlichkeit, von
Benutzern, Administratoren oder Überwachungstools entdeckt zu werden.

Ein unauffälligeres Vorgehen ist, bestimmte \glospl{port} in der Firewall freizugeben,
sodass auf diesen ungestört Daten gesendet und empfangen werden können.
Es müssen also nur Freigaben für von uns verwendete \glospl{port} hinzugefügt
werden. Dies wären \zB die \glospl{port} die zur Kommunikation mit der
\acr{msf}-Session verwendet werden.

Durch die \glos{port}-Freigaben kann unsere \acr{msf}-Session die Firewall
umgehen, obwohl sie weiterhin aktiv ist. Unsere Firewall-Manipulation kann
auch nur bei Überprüfung der Portfreigaben erkannt werden und hier
ist die Entdeckung unwahrscheinlicher.

Die ursprüngliche Idee war es, mit diesem Skript verschiedene
Firewalls manipulieren zu können. Allerdings stellt nur die native
Windows-Firewall ein \acr{cli} zur Verfügung, um die Firewall zu
konfigurieren. Untersuchte Firewalls, wie \zB
ZoneAlarm\footnote{\url{http://www.zonealarm.com/}}, können nur über
eine \acr{gui} konfiguriert werden und für uns bleibt nur die
Möglichkeit, die Firewall zu beenden.

Diese Optionen werden aber bereits von einigen \acr{msf}-Meterpreterskripten
umgesetzt, weswegen dieses Skript sich auf die Arbeit mit der
Windows-Firewall und deren \acr{cli} konzentriert.

Mit diesem Skript kann automatisch eine Freigabe für den aktuellen
\glos{port} der \acr{msf}-Session in der Windows-Firewall hinzugefügt werden.
Außerdem können auch beliebig weitere Freigaben für \glospl{port} hinzugefügt
oder entfernt werden. Es ist auch möglich, den Status der Windows-Firewall
auszulesen, oder die Windows-Firewall zu deaktivieren bzw. zu aktivieren.

\subsubsection{Reverse-HTTPS}
\authors{\DH}{\MW \and \JF}

Reverse-HTTPS ist ein \glos{payload} vom \acr{msf} und verfolgt das Ziel, aus
externen Netzen heraus auf einen internen Rechner zugreifen zu können,
ohne jedoch die Firewall manuell entsprechend konfigurieren zu
müssen. Dazu baut der interne Rechner zunächst eine Verbindung zu
einem bestimmten externen Rechner auf, wodurch der externe Rechner
über die Firewall hinweg mit dem internen Rechner kommunizieren kann.

Durch dieses Vorgehen stellen kompromittierte Hosts eine Verbindung
mit dem C\&C-Server des \f-Systems her.

\subsubsection{Reconnaissance-Skripte}
\label{sec:reconnaissance}
\authors{\WF\and\KUH}{\LM \and \DE \and \MW \and \JF}

Um von einem übernommenen Host weitere Hosts zu übernehmen, benötigen
wir zuerst Informationen über das Netz in dem sich der Host befindet.
Diese Informationen umfassen die dem Host bekannten IP-Adressen im
selben Sub-Netz, sowie weitere evtl. nützliche Informationen wie \zB
Benutzernamen und Passwörter. Um dies zu erreichen, wurden zusätzliche
Skripte geschrieben. Da \acr{metap} die Benutzung des
Kommandozeileninterpreters von Windows\footnote{Das Programm
  cmd.exe} ermöglicht, haben
wir uns im ersten Schritt diesen angeschaut, um herauszufinden, welche
Befehle für uns relevant sein könnten.

Bei der Recherche haben wir uns am Anfang auf die Befehle
konzentriert, die IP- und MAC-Adressen ermitteln, um zusätzliche Informationen
zu \glspl{glos:interface} und Hosts zu erhalten.

Dies konnte durch folgende Befehle realisiert werden:

\begin{itemize}
  \item \texttt{arp -a} (alle ARP Einträge werden ausgegeben)
  \item \texttt{ipconfig /all} (IP u. MAC-Adressen, Hostname, DNS-Adresse, etc.)
  \item \texttt{route print} (gibt die Route aus)
\end{itemize}

Aber auch mit Hilfe anderer Befehle wie \texttt{tasklist /svc} (Die laufenden
Prozesse) oder \texttt{netstat /nao} (Laufende Netzwerk-Prozesse und die
dazugehörigen IP-Adressen und Protokolle) konnten wir wichtige Informationen
gewinnen. 

Im Anschluss werden die Daten gefiltert und in die Datenbank
geschrieben, von wo aus sie von anderen Komponenten weiter verwendet
werden.  Im nächsten Schritt wurde überprüft, ob wir an
sicherheitsrelevante Daten gelangen können wie \zB Passwörter und
Benutzernamen. Dies kann \zB durch den \glos{hash} erreicht
werden. Dieser Hash wird zwar von Windows Programmen nicht verwendet, aber 
einige älteren Nicht-Windows Programme nutzen noch diese Funktionalität, 
weswegen trotzdem einige Benutzernamen und Passwörter erspäht werden können. 

Es wurde weiterhin überlegt, ob wir an detailliertere Informationen zu
den laufenden Prozessen kommen und diese ggf. als weitere
Backup-Sicherheitslücke ausnutzen können. Über den Befehl WMIC gelangt
man in die. In dieser Konsole gelangt man über Befehle an
Informationen über die laufenden Prozesse.  In dieser
Umgebung können wir \zB an die aktiven Prozesse und den Dateipfad der
dazugehörigen ausführbaren Datei gelangen, jedoch nicht an die Version des
Prozesses.

Um an die Informationen (wie \zB die Version) einer ausführbaren Datei
zu kommen, bedienen wir uns der Funktionalität des \acr{metap}s, jede
Bibliothek von Windows verwenden zu können. In unserem Fall benötigen
wir die \texttt{Version.dll} von Windows, in der sich die Methode
\texttt{GetFileVersionInfoW} befindet.  Diese Methode liest die von
uns benötigten Daten aus der Datei.

